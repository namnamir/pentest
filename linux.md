# Concepts
### Path
- An **absolute pathname** begins with the root directory and follows the tree, branch by branch, until it reaches the desired directory or file. Absolute paths always start with `/`.
- A **relative pathname** starts from the present working directory. Relative paths never start with `/`.
- Multiple slashes (/) between directories and files are allowed: `////usr//bin` equals to `/usr/bin`.

### (Hard/Soft) Link to Files
- A hard link is a pointer to a file where if the original file is deleted, the linked file works separately (a idendical copy of the original file).
- A soft (symbolic) link is the same as hard link but if the original file is delete, it would not work (a link to the original file).

###  Command Line Prompt
- The `PS1` variable is the character string that is displayed as the prompt on the command line.
- By changing the variable $PS1, the command prompt get changed; [read more](https://linuxconfig.org/bash-prompt-basics) about the possiblities.

### Standard File Streams
- When commands are executed, by default there are three standard file streams (or descriptors) always open for use: standard input (standard in or `stdin`), standard output (standard out or `stdout`) and standard error (or `stderr`).
- Usually, `stdin` is your keyboard, and `stdout` and `stderr` are printed on your terminal.
- 0: `stdin`, 1: `stdout`, 2: `stderr`.

### Pipes
- Pipeline allows Linux to combine the actions of several commands into one.

# Commands

### Other Commands
```
$ shutdown -h 10:00 "comment"       # turn of the computer at 10:00; -r represents restart
$ poweroff                          # like shutdown -h
$ halt                              # like shutdown -h

$ which diff                        # show the full path of (shell) commands
$ whereis diff                      # locate the binary, source, and manual page files for a command

$ locate t1                                 # search for the term t1 within file and directory's name. It uses the database for the searh
$ updatedb                                  # update the database used by the command locate
$ locate t1 | grep t2                       # search for the term t1 while the list contains the term t2
$ find d1 -type d -name "log*"              # find directories in the d1 directory that start with the term log
$ find / -size +10M                         # find files/directories in the root with the size more than 10MB
$ find / -ctime 3                           # find files/directories in the root with the metadata change time older than 3 days; -cmin represents minute
$ find / -amin -3                           # find files/directories in the root with the read (access) time newer than 3 minutes; -amin represents minute
$ find / -mmin 3 -exec [command] {} ’;’     # find files/directories in the root with the write (modification) time older than 3 days and run the command for the result, e.g. rm (delete them)

$ printenv                          # display all environmental variables

$ pwd                               # display the current directory
$ cd -                              # go to the previous directory

$ tree -d                           # show only directories
$ tree -C                           # colorize the output of tree
$ ls -i                             # show the unique inode (serial) number of files and folders
$ ls f?                             # show the list of files/directories' names start with f and has exactly one more charachter
$ ls f[b-s]                         # show the list of files/directories' names start with f and has exactly one more lette between b to s
$ ls f*                             # show the list of files/directories' names start with f and has zero or more charachter


$ ln f1 f2                          # hard link the file f1 to the file f2
$ ln -s f1 f2                       # soft link the file f1 to the file f2

$ pushd d1                          # push the directory d1 to the directory stack
$ dirs                              # show the directory stack
$ popd                              # go the the last directory in the directory stack and remove it from the stack

$ ip addr                           # show the list of NICs and IP/MAC addresses associated to each
$ ip address                        # same as ip addr

$ tac f1                            # opposite of the command cat. show the content from the last line to the first one
$ head -n 5 f1                      # show the first 5 line of the file f1; default number of lines is 10
$ tail -n 5 f1                      # show the last 5 line of the file f1; default number of lines is 15
$ less f1                           # show the full connent and let search (by using /) and scroll

$ rm -ri d1                         # remove contens of the directory d1 but interactively (ask the user for each deletion)

$ [command] < f1                    # reads from the file f1 and call the command
$ [command] > f1                    # run the command and write the output (stdout) in the file f1; 1> and > does the same
$ [command] 2> f1                   # run the command and write the error message (stderr) in the file f1
$ [command] >& f1                   # run the command and write the output and error message (stdout + stderr) in the file f1; >& and 2>&1 are the same

$ whatis ls                         # get a one-line manual page descriptions for all chapters
$ apropos ls                        # searche manual page names and descriptions for a user-supplied keyword
$ man –f ls                         # equivalent to whatis
$ man –k ls                         # equivalent to apropos
$ man -a socket                     # show the man pages for all "socket" chapters (it has two chapters 2 and 7)
$ ls --help                         # get the short description (equavalent to -h)

$ ps                                # list runing processes under the current shell
$ ps -lf                            # 
$ ps au                             # show processes in BSD style (without dash for options)
$ ps -fu 1000,ali                   # show processes by real user IDs or user names (here username: ali & ID: 1000); use -U for the effective one
$ ps -fg sudo                       # show processes by real the group ID or group name (here sudo); use -G for the effective one
$ ps -fp 1220                       # show processes by the process ID 1220
$ ps L                              # list all columns
$ ps -eo pid,%mem,%cpu --sort=-%cpu # show processes with the given columns and sort by the column %cpu
$ pstree                            # show processes in tree diagram shwoing parent and child processes
$ top                               # show the load average, uptiome, and processes (running, sleeping, etc.); load average is shown in 3 numbers for last 1, 5, and 15 mins
$ htop                              # show the processes info (like top)
$ w                                 # show the load average, user, IP, and the login time; load average is shown in 3 numbers for last 1, 5, and 15 mins
$ uptime                            # show the uptime and load average; load average is shown in 3 numbers for last 1, 5, and 15 mins
$ renice +5 1220                    # chenge the priority of the process 1220 and all its subprocesses. -20 is the topest priority and +19 is the lowest one
$ kill -SIGKILL 12                  # terminate the process 12
$ kill -9 12                        # terminate the process 12

$ jobs -l                           # show the list of jobs with their process IDs (go to background by Ctrl+Z or adding ' &' to the end of the command)
$ fg 1220                           # bring the job 1220 to foreground
$ bg                                # put the most recent job in background
$ at now + 2 days                   # run non-interactive command(s) in 2 days from now; commands will be defineds in CLI of 'at' later. User Ctrl+D to exit the interactive CLI
$ at now + 1 minute -f f1.sh        # run the bash file f1.sh in 1 minute from now
$ atq                               # show the list of jobs sechduled by 'at'
$ crontab -l                        # list all cron jobs of all users
$ crontab -u ali -l                 # list all cron jobs of the user 'ali'
$ crontab -e                        # edit cron jobs of the current user
$ crontab f1                        # put the file f1 (list of cron jobs) in the crontab system
$ crontab -r                        # remove the cron job
```

### Paths
```bash
/usr/share/doc                      # Linux package documentation
/etc/cron.d/	                      # Put all scripts here and call them from /etc/crontab file
/etc/cron.daily/	                  # Scripts run once a day
/etc/cron.hourly/	                  # Scripts run once an hour
/etc/cron.monthly/	                # Scripts run once a month
/etc/cron.weekly/	                  # Scripts run once a week
```

# Tools
### `top`: Overviewe of Processes
```
### top output
top - 13:01:39 up 10 days,  3:58,  1 user,  load average: 0.09, 0.17, 0.17
Tasks: 184 total,   1 running, 136 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.1 us,  0.2 sy,  0.0 ni, 99.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.2 st
KiB Mem :  8167536 total,  3988148 free,  1841892 used,  2337496 buff/cache
KiB Swap:  2097148 total,  2097148 free,        0 used.  5114672 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
14565 root      20   0  105696   6804   5828 S   0.7  0.1   0:00.02 sshd
    1 root      20   0  225404   9088   6648 S   0.3  0.1 263:25.66 systemd
```
- **1st line**: Shows the system uptime, the number of logged on users, and load average; load average is shown in 3 numbers for last 1, 5, and 15 mins.
- **2nd line**: Shows the total number of processes, the number of running, sleeping, stopped, and zombie processes.
- **3rd line**: Shows how the CPU time is being divided between users (us) and the kernel (sy) by displaying the percentage of CPU time used for each. The percentage of user jobs running at a lower priority (niceness - ni) is then listed. Idle mode (id) should be low if the load average is high, and vice versa. The percentage of jobs waiting (wa) for I/O is listed. Interrupts include the percentage of hardware (hi) vs. software interrupts (si). Steal time (st) is generally used with virtual machines, which has some of its idle CPU time taken for other uses.
- **4th line**: Shows the physical memory (RAM).
- **5th line**: Shows the swap space. Once the physical memory is exhausted, the system starts using swap space (temporary storage space on the hard drive) as an extended memory pool, and since accessing disk is much slower than accessing memory, this will negatively affect system performance.
- **7th line**: Process Identification Number (PID) | Process owner (USER) | Priority (PR) and nice values (NI) | Virtual (VIRT), physical (RES), and shared memory (SHR) | Status (S) | Percentage of CPU (%CPU) and memory (%MEM) used | Execution time (TIME+) | Command (COMMAND)
#### Interactive Keys
- **t** (CPU Time): Show/Hide/Change-Style lines 2 and 3
- **1**: Show/Hide each core of the CPU
- **m** (Memomry): Show/Hide/Change-Style lines 4 and 5
- **A**: Sort process by the resource consumption
- **r** (`renice`): Change the priority of the selected process or by typing the PID
- **k** (`kill`): Kill the selected process
- f: Add/Remove columns

### 'crontab': Define Scheduled Tasks
- The cron service (daemon) runs in the background and constantly checks the `/etc/crontab` file, and `/etc/cron.*/` directories. It also checks the `/var/spool/cron/` directory.
- By running `crontab -e` we can add cron jobs, each in a line, based on the following format.
```bash
1 7 * * * root /usr/local/bin/hourlyjob.sh
- - - - - ---- -----------------------
| | | | | |    |
| | | | | |    --- Command(s) including arguments and options
| | | | | -------- User
| | | | ---------- Day of week (0-7 or MON-SUN) (Sunday=0 or 7)
| | | ------------ Month (1-12 or JAN-DEC)
| | -------------- Day of month (1-31)
| ---------------- Hour (0-23)
------------- Minute (0-59)
```
- There are some pre-defined variables for cron jobs.
```bash
@reboot	    Run once, at startup
@yearly	    Run once a year:  0 0 1 1 *
@annually	  Run once a year:  0 0 1 1 *
@monthly	  Run once a month: 0 0 1 * *
@weekly	    Run once a week:  0 0 * * 0
@daily	    Run once a day:   0 0 * * *
@midnight	  Run once a day:   0 0 * * *
@hourly	    Run once an hour: 0 * * * *
```
#### Examples
```bash
12 22 *       *   1-5 /f1.sh  # run at 22:12 on weekdays
5  0  4       *   *   /f1.sh  # run at 5 mins after midnight every 4th of the month
*  10 *       */3 *   /f1.sh  # run every minute past 10 in every 3rd month
0  *  10-20/2 *   *   /f1.sh  # run every hour on every 2nd day of the month between 10-20th
0  *  1,10,20 *   *   /f1.sh  # run every hour on the 1st, 10th. and 20th of each month
```
